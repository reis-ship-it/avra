package com.spots.app

import android.app.ActivityManager
import android.content.Intent
import android.content.Context
import android.os.Build
import android.os.PowerManager
import android.os.StatFs
import androidx.core.content.ContextCompat
import com.spots.app.services.BleInboxStore
import com.spots.app.services.BLEForegroundService
import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MethodChannel
import java.io.File

class MainActivity: FlutterActivity() {
  private var localLlmEventSink: EventChannel.EventSink? = null
  private var localLlmModelDir: String? = null

  override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
    super.configureFlutterEngine(flutterEngine)

    BleInboxStore.init(applicationContext)

    MethodChannel(
      flutterEngine.dartExecutor.binaryMessenger,
      CHANNEL_BLE_INBOX,
    ).setMethodCallHandler { call, result ->
      when (call.method) {
        "pollMessages" -> {
          val maxMessages = call.argument<Number>("maxMessages")?.toInt() ?: 50
          val drained = BleInboxStore.drain(maxMessages)
          val mapped = drained.map { msg ->
            mapOf(
              "senderId" to msg.senderId,
              "data" to msg.data,
              "receivedAtMs" to msg.receivedAtMs,
            )
          }
          result.success(mapped)
        }
        "clearMessages" -> {
          BleInboxStore.clear()
          result.success(true)
        }
        else -> result.notImplemented()
      }
    }

    MethodChannel(
      flutterEngine.dartExecutor.binaryMessenger,
      CHANNEL_BLE_PERIPHERAL,
    ).setMethodCallHandler { call, result ->
      when (call.method) {
        "startPeripheral" -> {
          val payload = call.argument<ByteArray>("payload")
          if (payload == null) {
            result.success(false)
          } else {
            val ok = startBlePeripheral(payload)
            result.success(ok)
          }
        }
        "stopPeripheral" -> {
          val ok = stopBlePeripheral()
          result.success(ok)
        }
        "updatePayload" -> {
          val payload = call.argument<ByteArray>("payload")
          if (payload == null) {
            result.success(false)
          } else {
            val ok = updateBlePeripheralPayload(payload)
            result.success(ok)
          }
        }
        "updatePreKeyPayload" -> {
          val payload = call.argument<ByteArray>("payload")
          if (payload == null) {
            result.success(false)
          } else {
            val ok = updateBlePreKeyPayload(payload)
            result.success(ok)
          }
        }
        "updateServiceDataFrameV1" -> {
          val frame = call.argument<ByteArray>("frame")
          if (frame == null) {
            result.success(false)
          } else {
            val ok = updateBleServiceDataFrameV1(frame)
            result.success(ok)
          }
        }
        else -> result.notImplemented()
      }
    }

    MethodChannel(
      flutterEngine.dartExecutor.binaryMessenger,
      CHANNEL_BLE_FOREGROUND,
    ).setMethodCallHandler { call, result ->
      when (call.method) {
        "startService" -> {
          val ok = startBleForegroundService()
          result.success(ok)
        }
        "stopService" -> {
          val ok = stopBleForegroundService()
          result.success(ok)
        }
        "updateScanInterval" -> {
          val intervalMs = call.argument<Number>("intervalMs")?.toLong()
          if (intervalMs == null || intervalMs < 0L) {
            result.success(false)
          } else {
            val ok = updateScanInterval(intervalMs)
            result.success(ok)
          }
        }
        else -> result.notImplemented()
      }
    }

    MethodChannel(
      flutterEngine.dartExecutor.binaryMessenger,
      CHANNEL_DEVICE_CAPABILITIES,
    ).setMethodCallHandler { call, result ->
      when (call.method) {
        "getCapabilities" -> {
          try {
            val am = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
            val mi = ActivityManager.MemoryInfo()
            am.getMemoryInfo(mi)
            val totalRamMb = (mi.totalMem / (1024L * 1024L)).toInt()

            val stat = StatFs(filesDir.absolutePath)
            val freeDiskMb = (stat.availableBytes / (1024L * 1024L)).toInt()
            val totalDiskMb = (stat.totalBytes / (1024L * 1024L)).toInt()

            val pm = getSystemService(Context.POWER_SERVICE) as PowerManager
            val isLowPowerMode = pm.isPowerSaveMode

            val payload = mapOf(
              "platform" to "android",
              "deviceModel" to (Build.MODEL ?: ""),
              "osVersion" to Build.VERSION.SDK_INT,
              "totalRamMb" to totalRamMb,
              "freeDiskMb" to freeDiskMb,
              "totalDiskMb" to totalDiskMb,
              "cpuCores" to Runtime.getRuntime().availableProcessors(),
              "isLowPowerMode" to isLowPowerMode,
            )
            result.success(payload)
          } catch (e: Exception) {
            result.error("capabilities_error", e.toString(), null)
          }
        }
        else -> result.notImplemented()
      }
    }

    EventChannel(
      flutterEngine.dartExecutor.binaryMessenger,
      CHANNEL_LOCAL_LLM_STREAM,
    ).setStreamHandler(object : EventChannel.StreamHandler {
      override fun onListen(arguments: Any?, events: EventChannel.EventSink?) {
        localLlmEventSink = events
      }

      override fun onCancel(arguments: Any?) {
        localLlmEventSink = null
      }
    })

    MethodChannel(
      flutterEngine.dartExecutor.binaryMessenger,
      CHANNEL_LOCAL_LLM,
    ).setMethodCallHandler { call, result ->
      when (call.method) {
        "loadModel" -> {
          val modelDir = call.argument<String>("model_dir") ?: ""
          if (modelDir.isEmpty()) {
            localLlmModelDir = null
            result.success(false)
          } else {
            // Basic validation: directory exists and contains at least one .gguf.
            val dir = File(modelDir)
            val ok = dir.exists() && dir.isDirectory && (dir.listFiles()?.any { it.name.endsWith(".gguf") } == true)
            localLlmModelDir = if (ok) modelDir else null
            result.success(ok)
          }
        }
        "generate" -> {
          val modelDir = call.argument<String>("model_dir") ?: ""
          if (modelDir.isEmpty()) {
            result.error("no_model", "Missing model_dir", null)
          } else if (localLlmModelDir == null || localLlmModelDir != modelDir) {
            result.error("not_ready", "Local LLM not loaded", null)
          } else {
            result.error("not_ready", "Local LLM not yet active on Android", null)
          }
        }
        "startStream" -> {
          val modelDir = call.argument<String>("model_dir") ?: ""
          if (modelDir.isEmpty()) {
            localLlmEventSink?.success(mapOf("type" to "error", "message" to "Missing model_dir"))
            localLlmEventSink?.success(mapOf("type" to "done"))
            result.success(false)
          } else if (localLlmModelDir == null || localLlmModelDir != modelDir) {
            localLlmEventSink?.success(mapOf("type" to "error", "message" to "Local LLM not loaded"))
            localLlmEventSink?.success(mapOf("type" to "done"))
            result.success(true)
          } else {
            val sink = localLlmEventSink
            if (sink == null) {
              result.success(false)
              return@setMethodCallHandler
            }
            runOnUiThread {
              sink.success(mapOf("type" to "error", "message" to "Local LLM not yet active on Android"))
              sink.success(mapOf("type" to "done"))
            }
            result.success(true)
          }
        }
        else -> result.notImplemented()
      }
    }
  }

  private fun startBleForegroundService(): Boolean {
    return try {
      val intent = Intent(this, BLEForegroundService::class.java).apply {
        action = BLEForegroundService.ACTION_START
      }
      ContextCompat.startForegroundService(this, intent)
      true
    } catch (e: Exception) {
      false
    }
  }

  private fun stopBleForegroundService(): Boolean {
    return try {
      val intent = Intent(this, BLEForegroundService::class.java).apply {
        action = BLEForegroundService.ACTION_STOP
      }
      startService(intent)
      stopService(Intent(this, BLEForegroundService::class.java))
      true
    } catch (e: Exception) {
      false
    }
  }

  private fun updateScanInterval(intervalMs: Long): Boolean {
    return try {
      val intent = Intent(this, BLEForegroundService::class.java).apply {
        action = BLEForegroundService.ACTION_UPDATE_SCAN_INTERVAL
        putExtra(BLEForegroundService.EXTRA_SCAN_INTERVAL_MS, intervalMs)
      }
      startService(intent)
      true
    } catch (e: Exception) {
      false
    }
  }

  private fun startBlePeripheral(payload: ByteArray): Boolean {
    return try {
      val intent = Intent(this, BLEForegroundService::class.java).apply {
        action = BLEForegroundService.ACTION_START_PERIPHERAL
        putExtra(BLEForegroundService.EXTRA_PERIPHERAL_PAYLOAD_BYTES, payload)
      }
      ContextCompat.startForegroundService(this, intent)
      true
    } catch (e: Exception) {
      false
    }
  }

  private fun stopBlePeripheral(): Boolean {
    return try {
      val intent = Intent(this, BLEForegroundService::class.java).apply {
        action = BLEForegroundService.ACTION_STOP_PERIPHERAL
      }
      startService(intent)
      true
    } catch (e: Exception) {
      false
    }
  }

  private fun updateBlePeripheralPayload(payload: ByteArray): Boolean {
    return try {
      val intent = Intent(this, BLEForegroundService::class.java).apply {
        action = BLEForegroundService.ACTION_SET_VIBE_PAYLOAD
        putExtra(BLEForegroundService.EXTRA_PERIPHERAL_PAYLOAD_BYTES, payload)
      }
      startService(intent)
      true
    } catch (e: Exception) {
      false
    }
  }

  private fun updateBlePreKeyPayload(payload: ByteArray): Boolean {
    return try {
      val intent = Intent(this, BLEForegroundService::class.java).apply {
        action = BLEForegroundService.ACTION_SET_PREKEY_PAYLOAD
        putExtra(BLEForegroundService.EXTRA_PREKEY_PAYLOAD_BYTES, payload)
      }
      startService(intent)
      true
    } catch (e: Exception) {
      false
    }
  }

  private fun updateBleServiceDataFrameV1(frame: ByteArray): Boolean {
    return try {
      val intent = Intent(this, BLEForegroundService::class.java).apply {
        action = BLEForegroundService.ACTION_SET_SERVICE_DATA_FRAME_V1
        putExtra(BLEForegroundService.EXTRA_SERVICE_DATA_FRAME_V1_BYTES, frame)
      }
      startService(intent)
      true
    } catch (e: Exception) {
      false
    }
  }

  companion object {
    private const val CHANNEL_BLE_FOREGROUND = "spots/ble_foreground"
    private const val CHANNEL_BLE_PERIPHERAL = "spots/ble_peripheral"
    private const val CHANNEL_BLE_INBOX = "spots/ble_inbox"
    private const val CHANNEL_DEVICE_CAPABILITIES = "spots/device_capabilities"
    private const val CHANNEL_LOCAL_LLM = "spots/local_llm"
    private const val CHANNEL_LOCAL_LLM_STREAM = "spots/local_llm_stream"
  }
} 