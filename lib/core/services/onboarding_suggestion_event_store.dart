import 'dart:developer' as developer;

import 'package:get_it/get_it.dart';
import 'package:sembast/sembast.dart';
import 'package:spots/core/models/onboarding_suggestion_event.dart';
import 'package:spots/core/services/agent_id_service.dart';
import 'package:spots/data/datasources/local/sembast_database.dart';

/// Stores onboarding “suggestion events” (provenance + user reactions) keyed by agentId.
///
/// This is separate from `OnboardingData` because we want to log events *during*
/// onboarding (before the final `OnboardingData` object is complete/validated),
/// and we want an append-only event log for later bootstrap and analytics.
class OnboardingSuggestionEventStore {
  static const String _logName = 'OnboardingSuggestionEventStore';
  static const String _eventsKeyPrefix = 'onboarding_suggestion_events_';
  static const String _eventsField = 'events';
  static const String _updatedAtMsField = 'updatedAtMs';

  final AgentIdService _agentIdService;

  static AgentIdService _resolveAgentIdService() {
    try {
      final sl = GetIt.instance;
      if (sl.isRegistered<AgentIdService>()) {
        return sl<AgentIdService>();
      }
    } catch (_) {
      // Fall through to a safe default instance.
    }
    return AgentIdService();
  }

  OnboardingSuggestionEventStore({AgentIdService? agentIdService})
      : _agentIdService = agentIdService ?? _resolveAgentIdService();

  Future<void> appendForUser({
    required String userId,
    required OnboardingSuggestionEvent event,
  }) async {
    try {
      final agentId = await _agentIdService.getUserAgentId(userId);
      final db = await SembastDatabase.database;
      final store = SembastDatabase.onboardingStore;

      final key = '$_eventsKeyPrefix$agentId';
      final existing = await store.record(key).get(db);
      final existingEvents = (existing?[_eventsField] as List?) ?? const [];
      final events = existingEvents.map((e) => e).toList();

      events.add(event.toJson());
      await store.record(key).put(db, <String, dynamic>{
        _eventsField: events,
        _updatedAtMsField: DateTime.now().millisecondsSinceEpoch,
      });

      developer.log(
        'Appended onboarding suggestion event: ${event.surface}/${event.provenance.name}/${event.userAction?.type.name ?? 'none'}',
        name: _logName,
      );
    } catch (e, st) {
      developer.log(
        'Failed to append onboarding suggestion event: $e',
        name: _logName,
        error: e,
        stackTrace: st,
      );
    }
  }

  Future<List<OnboardingSuggestionEvent>> getAllForUser(String userId) async {
    try {
      final agentId = await _agentIdService.getUserAgentId(userId);
      final db = await SembastDatabase.database;
      final store = SembastDatabase.onboardingStore;

      final key = '$_eventsKeyPrefix$agentId';
      final existing = await store.record(key).get(db);
      final events = (existing?[_eventsField] as List?) ?? const [];

      return events
          .whereType<Map>()
          .map((e) => OnboardingSuggestionEvent.fromJson(Map<String, dynamic>.from(e)))
          .toList();
    } catch (e, st) {
      developer.log(
        'Failed to load onboarding suggestion events: $e',
        name: _logName,
        error: e,
        stackTrace: st,
      );
      return const [];
    }
  }

  Future<void> clearForUser(String userId) async {
    try {
      final agentId = await _agentIdService.getUserAgentId(userId);
      final db = await SembastDatabase.database;
      final store = SembastDatabase.onboardingStore;

      final key = '$_eventsKeyPrefix$agentId';
      await store.record(key).delete(db);
    } catch (e, st) {
      developer.log(
        'Failed to clear onboarding suggestion events: $e',
        name: _logName,
        error: e,
        stackTrace: st,
      );
    }
  }
}

