// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Generate knot from braid sequence data
///
/// Input: braid_data as flat vector [strands, crossing1_strand, crossing1_over, ...]
/// Output: KnotResult with knot data and invariants
KnotResult generateKnotFromBraid({required List<double> braidData}) =>
    RustLib.instance.api.crateApiGenerateKnotFromBraid(braidData: braidData);

/// Calculate Jones polynomial from braid data
///
/// Input: braid_data as flat vector [strands, crossing1_strand, crossing1_over, ...]
/// Output: Polynomial coefficients (lowest degree first)
Float64List calculateJonesPolynomial({required List<double> braidData}) =>
    RustLib.instance.api.crateApiCalculateJonesPolynomial(braidData: braidData);

/// Calculate Alexander polynomial from braid data
///
/// Input: braid_data as flat vector [strands, crossing1_strand, crossing1_over, ...]
/// Output: Polynomial coefficients (lowest degree first)
Float64List calculateAlexanderPolynomial({required List<double> braidData}) =>
    RustLib.instance.api
        .crateApiCalculateAlexanderPolynomial(braidData: braidData);

/// Calculate topological compatibility between two knots
///
/// Input: Two braid_data vectors
/// Output: Compatibility score in [0, 1]
double calculateTopologicalCompatibility(
        {required List<double> braidDataA, required List<double> braidDataB}) =>
    RustLib.instance.api.crateApiCalculateTopologicalCompatibility(
        braidDataA: braidDataA, braidDataB: braidDataB);

/// Calculate writhe of a braid
///
/// Input: braid_data as flat vector [strands, crossing1_strand, crossing1_over, ...]
/// Output: Writhe (signed integer)
int calculateWritheFromBraid({required List<double> braidData}) =>
    RustLib.instance.api.crateApiCalculateWritheFromBraid(braidData: braidData);

/// Calculate crossing number of a braid
///
/// Input: braid_data as flat vector [strands, crossing1_strand, crossing1_over, ...]
/// Output: Crossing number (unsigned integer)
BigInt calculateCrossingNumberFromBraid({required List<double> braidData}) =>
    RustLib.instance.api
        .crateApiCalculateCrossingNumberFromBraid(braidData: braidData);

/// Evaluate polynomial at a point
///
/// Input: coefficients (lowest degree first), x value
/// Output: Polynomial value at x
double evaluatePolynomial(
        {required List<double> coefficients, required double x}) =>
    RustLib.instance.api
        .crateApiEvaluatePolynomial(coefficients: coefficients, x: x);

/// Calculate distance between two polynomials
///
/// Input: Two coefficient vectors
/// Output: L2 distance
double polynomialDistance(
        {required List<double> coefficientsA,
        required List<double> coefficientsB}) =>
    RustLib.instance.api.crateApiPolynomialDistance(
        coefficientsA: coefficientsA, coefficientsB: coefficientsB);

/// Calculate knot energy from knot points
///
/// Input: knot_points as [x1, y1, z1, x2, y2, z2, ...]
/// Output: Energy value
double calculateKnotEnergyFromPoints({required List<double> knotPoints}) =>
    RustLib.instance.api
        .crateApiCalculateKnotEnergyFromPoints(knotPoints: knotPoints);

/// Calculate knot stability from knot points
///
/// Input: knot_points as [x1, y1, z1, x2, y2, z2, ...]
/// Output: Stability value
double calculateKnotStabilityFromPoints({required List<double> knotPoints}) =>
    RustLib.instance.api
        .crateApiCalculateKnotStabilityFromPoints(knotPoints: knotPoints);

/// Calculate Boltzmann distribution
///
/// Input: energies (Vec&lt;f64&gt;), temperature (f64)
/// Output: Probability distribution (Vec&lt;f64&gt;)
Float64List calculateBoltzmannDistribution(
        {required List<double> energies, required double temperature}) =>
    RustLib.instance.api.crateApiCalculateBoltzmannDistribution(
        energies: energies, temperature: temperature);

/// Calculate entropy from probability distribution
///
/// Input: probabilities (Vec&lt;f64&gt;)
/// Output: Entropy value
double calculateEntropy({required List<double> probabilities}) =>
    RustLib.instance.api.crateApiCalculateEntropy(probabilities: probabilities);

/// Calculate free energy
///
/// Input: energy (f64), entropy (f64), temperature (f64)
/// Output: Free energy value
double calculateFreeEnergy(
        {required double energy,
        required double entropy,
        required double temperature}) =>
    RustLib.instance.api.crateApiCalculateFreeEnergy(
        energy: energy, entropy: entropy, temperature: temperature);

/// Result type for knot generation (FFI-compatible)
class KnotResult {
  final Float64List knotData;
  final Float64List jonesPolynomial;
  final Float64List alexanderPolynomial;
  final BigInt crossingNumber;
  final int writhe;

  const KnotResult({
    required this.knotData,
    required this.jonesPolynomial,
    required this.alexanderPolynomial,
    required this.crossingNumber,
    required this.writhe,
  });

  @override
  int get hashCode =>
      knotData.hashCode ^
      jonesPolynomial.hashCode ^
      alexanderPolynomial.hashCode ^
      crossingNumber.hashCode ^
      writhe.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KnotResult &&
          runtimeType == other.runtimeType &&
          knotData == other.knotData &&
          jonesPolynomial == other.jonesPolynomial &&
          alexanderPolynomial == other.alexanderPolynomial &&
          crossingNumber == other.crossingNumber &&
          writhe == other.writhe;
}
