import 'package:flutter_test/flutter_test.dart';
import 'package:spots/core/services/expert_recommendations_service.dart';
import 'package:spots/core/models/unified_user.dart';
import '../../fixtures/model_factories.dart';
import '../../helpers/platform_channel_helper.dart';

/// Expert Recommendations Service Tests
/// Tests expert-based recommendation functionality
void main() {
  group('ExpertRecommendationsService Tests', () {
    late ExpertRecommendationsService service;
    late UnifiedUser user;

    setUp(() {
      service = ExpertRecommendationsService();
      user = ModelFactories.createTestUser(
        id: 'user-123',
        tags: ['food'],
      ).copyWith(
        expertiseMap: {'food': 'city'},
      );
    });

    // Removed: Property assignment tests
    // Expert recommendations tests focus on business logic (recommendations, curated lists, validated spots), not property assignment

    group('getExpertRecommendations', () {
      test(
          'should return recommendations for user with expertise, return general recommendations when user has no expertise, respect maxResults parameter, use user expertise categories when category not specified, or return recommendations sorted by score',
          () async {
        // Test business logic: expert recommendation retrieval
        final recommendations1 = await service.getExpertRecommendations(
          user,
          category: 'food',
        );
        expect(recommendations1, isA<List<ExpertRecommendation>>());
        for (var i = 0; i < recommendations1.length - 1; i++) {
          expect(
            recommendations1[i].recommendationScore,
            greaterThanOrEqualTo(recommendations1[i + 1].recommendationScore),
          );
        }

        final userWithoutExpertise = ModelFactories.createTestUser(
          id: 'user-456',
        ).copyWith(expertiseMap: {});
        final recommendations2 = await service.getExpertRecommendations(
          userWithoutExpertise,
        );
        expect(recommendations2, isA<List<ExpertRecommendation>>());

        final recommendations3 = await service.getExpertRecommendations(
          user,
          category: 'food',
          maxResults: 10,
        );
        expect(recommendations3.length, lessThanOrEqualTo(10));

        final recommendations4 = await service.getExpertRecommendations(
          user,
          maxResults: 20,
        );
        expect(recommendations4, isA<List<ExpertRecommendation>>());
      });
    });

    group('getExpertCuratedLists', () {
      test(
          'should return expert-curated lists, respect maxResults parameter, or filter by category when provided',
          () async {
        // Test business logic: expert-curated list retrieval
        final lists1 = await service.getExpertCuratedLists(
          user,
          category: 'food',
        );
        expect(lists1, isA<List<ExpertCuratedList>>());
        for (final list in lists1) {
          expect(list.category, equals('food'));
        }

        final lists2 = await service.getExpertCuratedLists(
          user,
          category: 'food',
          maxResults: 5,
        );
        expect(lists2.length, lessThanOrEqualTo(5));
      });
    });

    group('getExpertValidatedSpots', () {
      test(
          'should return expert-validated spots, respect maxResults parameter, or filter by location when provided',
          () async {
        // Test business logic: expert-validated spot retrieval
        final spots1 = await service.getExpertValidatedSpots(
          category: 'food',
          location: 'San Francisco',
        );
        expect(spots1, isA<List>());

        final spots2 = await service.getExpertValidatedSpots(
          category: 'food',
          maxResults: 10,
        );
        expect(spots2.length, lessThanOrEqualTo(10));

        final spots3 = await service.getExpertValidatedSpots(
          category: 'coffee',
          location: 'New York',
        );
        expect(spots3, isA<List>());
      });
    });

    tearDownAll(() async {
      await cleanupTestStorage();
    });
  });
}
