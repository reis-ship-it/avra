// Mocks generated by Mockito 5.4.6 from annotations
// in spots/test/unit/services/expansion_expertise_gain_service_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:async' as _i4;

import 'package:mockito/mockito.dart' as _i1;
import 'package:spots/core/models/expertise_event.dart' as _i5;
import 'package:spots/core/models/geographic_expansion.dart' as _i2;
import 'package:spots/core/services/geographic_expansion_service.dart' as _i3;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: must_be_immutable
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class
// ignore_for_file: invalid_use_of_internal_member

class _FakeGeographicExpansion_0 extends _i1.SmartFake
    implements _i2.GeographicExpansion {
  _FakeGeographicExpansion_0(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

/// A class which mocks [GeographicExpansionService].
///
/// See the documentation for Mockito's code generation for more information.
class MockGeographicExpansionService extends _i1.Mock
    implements _i3.GeographicExpansionService {
  MockGeographicExpansionService() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i4.Future<_i2.GeographicExpansion> trackEventExpansion({
    required String? clubId,
    required bool? isClub,
    required _i5.ExpertiseEvent? event,
    required String? eventLocation,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #trackEventExpansion,
          [],
          {
            #clubId: clubId,
            #isClub: isClub,
            #event: event,
            #eventLocation: eventLocation,
          },
        ),
        returnValue: _i4.Future<_i2.GeographicExpansion>.value(
            _FakeGeographicExpansion_0(
          this,
          Invocation.method(
            #trackEventExpansion,
            [],
            {
              #clubId: clubId,
              #isClub: isClub,
              #event: event,
              #eventLocation: eventLocation,
            },
          ),
        )),
      ) as _i4.Future<_i2.GeographicExpansion>);

  @override
  _i4.Future<_i2.GeographicExpansion> trackCommutePattern({
    required String? clubId,
    required String? eventLocality,
    required List<String>? attendeeLocalities,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #trackCommutePattern,
          [],
          {
            #clubId: clubId,
            #eventLocality: eventLocality,
            #attendeeLocalities: attendeeLocalities,
          },
        ),
        returnValue: _i4.Future<_i2.GeographicExpansion>.value(
            _FakeGeographicExpansion_0(
          this,
          Invocation.method(
            #trackCommutePattern,
            [],
            {
              #clubId: clubId,
              #eventLocality: eventLocality,
              #attendeeLocalities: attendeeLocalities,
            },
          ),
        )),
      ) as _i4.Future<_i2.GeographicExpansion>);

  @override
  _i4.Future<Map<String, double>> calculateLocalityCoverage(
          {required _i2.GeographicExpansion? expansion}) =>
      (super.noSuchMethod(
        Invocation.method(
          #calculateLocalityCoverage,
          [],
          {#expansion: expansion},
        ),
        returnValue: _i4.Future<Map<String, double>>.value(<String, double>{}),
      ) as _i4.Future<Map<String, double>>);

  @override
  _i4.Future<Map<String, double>> calculateCityCoverage(
          {required _i2.GeographicExpansion? expansion}) =>
      (super.noSuchMethod(
        Invocation.method(
          #calculateCityCoverage,
          [],
          {#expansion: expansion},
        ),
        returnValue: _i4.Future<Map<String, double>>.value(<String, double>{}),
      ) as _i4.Future<Map<String, double>>);

  @override
  _i4.Future<Map<String, double>> calculateStateCoverage(
          {required _i2.GeographicExpansion? expansion}) =>
      (super.noSuchMethod(
        Invocation.method(
          #calculateStateCoverage,
          [],
          {#expansion: expansion},
        ),
        returnValue: _i4.Future<Map<String, double>>.value(<String, double>{}),
      ) as _i4.Future<Map<String, double>>);

  @override
  _i4.Future<Map<String, double>> calculateNationCoverage(
          {required _i2.GeographicExpansion? expansion}) =>
      (super.noSuchMethod(
        Invocation.method(
          #calculateNationCoverage,
          [],
          {#expansion: expansion},
        ),
        returnValue: _i4.Future<Map<String, double>>.value(<String, double>{}),
      ) as _i4.Future<Map<String, double>>);

  @override
  _i4.Future<double> calculateGlobalCoverage(
          {required _i2.GeographicExpansion? expansion}) =>
      (super.noSuchMethod(
        Invocation.method(
          #calculateGlobalCoverage,
          [],
          {#expansion: expansion},
        ),
        returnValue: _i4.Future<double>.value(0.0),
      ) as _i4.Future<double>);

  @override
  bool hasReachedLocalityThreshold(_i2.GeographicExpansion? expansion) =>
      (super.noSuchMethod(
        Invocation.method(
          #hasReachedLocalityThreshold,
          [expansion],
        ),
        returnValue: false,
      ) as bool);

  @override
  bool hasReachedCityThreshold(
    _i2.GeographicExpansion? expansion,
    String? city,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #hasReachedCityThreshold,
          [
            expansion,
            city,
          ],
        ),
        returnValue: false,
      ) as bool);

  @override
  bool hasReachedStateThreshold(
    _i2.GeographicExpansion? expansion,
    String? state,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #hasReachedStateThreshold,
          [
            expansion,
            state,
          ],
        ),
        returnValue: false,
      ) as bool);

  @override
  bool hasReachedNationThreshold(
    _i2.GeographicExpansion? expansion,
    String? nation,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #hasReachedNationThreshold,
          [
            expansion,
            nation,
          ],
        ),
        returnValue: false,
      ) as bool);

  @override
  bool hasReachedGlobalThreshold(_i2.GeographicExpansion? expansion) =>
      (super.noSuchMethod(
        Invocation.method(
          #hasReachedGlobalThreshold,
          [expansion],
        ),
        returnValue: false,
      ) as bool);

  @override
  _i2.GeographicExpansion? getExpansionByClub(String? clubId) =>
      (super.noSuchMethod(Invocation.method(
        #getExpansionByClub,
        [clubId],
      )) as _i2.GeographicExpansion?);

  @override
  _i2.GeographicExpansion? getExpansionByCommunity(String? communityId) =>
      (super.noSuchMethod(Invocation.method(
        #getExpansionByCommunity,
        [communityId],
      )) as _i2.GeographicExpansion?);

  @override
  _i4.Future<_i2.GeographicExpansion> updateExpansion(
          _i2.GeographicExpansion? expansion) =>
      (super.noSuchMethod(
        Invocation.method(
          #updateExpansion,
          [expansion],
        ),
        returnValue: _i4.Future<_i2.GeographicExpansion>.value(
            _FakeGeographicExpansion_0(
          this,
          Invocation.method(
            #updateExpansion,
            [expansion],
          ),
        )),
      ) as _i4.Future<_i2.GeographicExpansion>);

  @override
  List<_i2.ExpansionEvent> getExpansionHistory(String? clubId) =>
      (super.noSuchMethod(
        Invocation.method(
          #getExpansionHistory,
          [clubId],
        ),
        returnValue: <_i2.ExpansionEvent>[],
      ) as List<_i2.ExpansionEvent>);
}
